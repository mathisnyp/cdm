{"version":3,"sources":["../../src/core/Tokenizer.ts"],"names":["NULL_REGEX","Tokenizer","cfg","tokenType","input","getTokenOnFirstMatch","type","regex","REGEX_MAP","WHITESPACE_REGEX","specialWordCharsAll","Object","values","specialWordChars","join","TokenType","WORD","regexFactory","createWordRegex","STRING","createStringRegex","stringTypes","RESERVED_KEYWORD","createReservedWordRegex","reservedKeywords","RESERVED_DEPENDENT_CLAUSE","reservedDependentClauses","RESERVED_LOGICAL_OPERATOR","reservedLogicalOperators","RESERVED_COMMAND","reservedCommands","RESERVED_BINARY_COMMAND","reservedBinaryCommands","OPERATOR","createOperatorRegex","operators","BLOCK_START","createParenRegex","blockStart","BLOCK_END","blockEnd","LINE_COMMENT","createLineCommentRegex","lineCommentTypes","BLOCK_COMMENT","NUMBER","PLACEHOLDER","INDEXED_PLACEHOLDER_REGEX","createPlaceholderRegex","indexedPlaceholderTypes","IDENT_NAMED_PLACEHOLDER_REGEX","namedPlaceholderTypes","STRING_NAMED_PLACEHOLDER_REGEX","createStringPattern","tokens","token","length","whitespaceBefore","getWhitespace","substring","getNextToken","value","push","matches","match","previousToken","matchToken","getPlaceholderToken","getReservedWordToken","placeholderTokenRegexMap","parseKey","v","slice","getEscapedPlaceholderKey","key","quoteChar","reduce","acc","undefined","replace","RegExp","includes","reservedTokenList","matchedToken"],"mappings":"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","sourcesContent":["import * as regexFactory from './regexFactory';\nimport { escapeRegExp } from '../utils';\nimport { Token, TokenType } from './token'; // convert to partial type import in TS 4.5\n\nconst NULL_REGEX = /(?!)/; // zero-width negative lookahead, matches nothing\n\n/** Struct that defines how a SQL language can be broken into tokens */\ninterface TokenizerOptions {\n\treservedKeywords: string[];\n\treservedCommands: string[];\n\treservedLogicalOperators: string[];\n\treservedDependentClauses: string[];\n\treservedBinaryCommands: string[];\n\tstringTypes: regexFactory.StringPatternType[];\n\tblockStart: string[];\n\tblockEnd: string[];\n\tindexedPlaceholderTypes?: string[];\n\tnamedPlaceholderTypes: string[];\n\tlineCommentTypes: string[];\n\tspecialWordChars?: { prefix?: string; any?: string; suffix?: string };\n\toperators?: string[];\n}\n\n/** Converts SQL language string into a token stream */\nexport default class Tokenizer {\n\tWHITESPACE_REGEX: RegExp;\n\tREGEX_MAP: { [tokenType in TokenType]: RegExp };\n\n\tINDEXED_PLACEHOLDER_REGEX?: RegExp;\n\tIDENT_NAMED_PLACEHOLDER_REGEX?: RegExp;\n\tSTRING_NAMED_PLACEHOLDER_REGEX?: RegExp;\n\n\t/**\n\t * @param {TokenizerOptions} cfg\n\t *  @param {string[]} cfg.reservedKeywords - Reserved words in SQL\n\t *  @param {string[]} cfg.reservedDependentClauses - Words that following a specific Statement and must have data attached\n\t *  @param {string[]} cfg.reservedLogicalOperators - Words that are set to newline\n\t *  @param {string[]} cfg.reservedCommands - Words that are set to new line separately\n\t *  @param {string[]} cfg.reservedBinaryCommands - Words that are top level but have no indentation\n\t *  @param {string[]} cfg.stringTypes - string types to enable - \"\", '', ``, [], N''\n\t *  @param {string[]} cfg.blockStart - Opening parentheses to enable, like (, [\n\t *  @param {string[]} cfg.blockEnd - Closing parentheses to enable, like ), ]\n\t *  @param {string[]} cfg.indexedPlaceholderTypes - Prefixes for indexed placeholders, like ?\n\t *  @param {string[]} cfg.namedPlaceholderTypes - Prefixes for named placeholders, like @ and :\n\t *  @param {string[]} cfg.lineCommentTypes - Line comments to enable, like # and --\n\t *  @param {string[]} cfg.specialWordChars - Special chars that can be found inside of words, like @ and #\n\t *  @param {string[]} cfg.operators - Additional operators to recognize\n\t */\n\tconstructor(cfg: TokenizerOptions) {\n\t\tthis.WHITESPACE_REGEX = /^(\\s+)/u;\n\n\t\tconst specialWordCharsAll = Object.values(cfg.specialWordChars ?? {}).join('');\n\t\tthis.REGEX_MAP = {\n\t\t\t[TokenType.WORD]: regexFactory.createWordRegex(cfg.specialWordChars),\n\t\t\t[TokenType.STRING]: regexFactory.createStringRegex(cfg.stringTypes),\n\t\t\t[TokenType.RESERVED_KEYWORD]: regexFactory.createReservedWordRegex(\n\t\t\t\tcfg.reservedKeywords,\n\t\t\t\tspecialWordCharsAll\n\t\t\t),\n\t\t\t[TokenType.RESERVED_DEPENDENT_CLAUSE]: regexFactory.createReservedWordRegex(\n\t\t\t\tcfg.reservedDependentClauses ?? [],\n\t\t\t\tspecialWordCharsAll\n\t\t\t),\n\t\t\t[TokenType.RESERVED_LOGICAL_OPERATOR]: regexFactory.createReservedWordRegex(\n\t\t\t\tcfg.reservedLogicalOperators,\n\t\t\t\tspecialWordCharsAll\n\t\t\t),\n\t\t\t[TokenType.RESERVED_COMMAND]: regexFactory.createReservedWordRegex(\n\t\t\t\tcfg.reservedCommands,\n\t\t\t\tspecialWordCharsAll\n\t\t\t),\n\t\t\t[TokenType.RESERVED_BINARY_COMMAND]: regexFactory.createReservedWordRegex(\n\t\t\t\tcfg.reservedBinaryCommands,\n\t\t\t\tspecialWordCharsAll\n\t\t\t),\n\t\t\t[TokenType.OPERATOR]: regexFactory.createOperatorRegex('+-/*%&|^><=.,;[]{}`:$', [\n\t\t\t\t'<>',\n\t\t\t\t'<=',\n\t\t\t\t'>=',\n\t\t\t\t'!=',\n\t\t\t\t...(cfg.operators ?? []),\n\t\t\t]),\n\t\t\t[TokenType.BLOCK_START]: regexFactory.createParenRegex(cfg.blockStart),\n\t\t\t[TokenType.BLOCK_END]: regexFactory.createParenRegex(cfg.blockEnd),\n\t\t\t[TokenType.LINE_COMMENT]: regexFactory.createLineCommentRegex(cfg.lineCommentTypes),\n\t\t\t[TokenType.BLOCK_COMMENT]: /^(\\/\\*[^]*?(?:\\*\\/|$))/u,\n\t\t\t[TokenType.NUMBER]:\n\t\t\t\t/^((-\\s*)?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+(\\.[0-9]+)?)?|0x[0-9a-fA-F]+|0b[01]+)/u,\n\t\t\t[TokenType.PLACEHOLDER]: NULL_REGEX, // matches nothing\n\t\t};\n\n\t\tthis.INDEXED_PLACEHOLDER_REGEX = regexFactory.createPlaceholderRegex(\n\t\t\tcfg.indexedPlaceholderTypes ?? [],\n\t\t\t'[0-9]*'\n\t\t);\n\t\tthis.IDENT_NAMED_PLACEHOLDER_REGEX = regexFactory.createPlaceholderRegex(\n\t\t\tcfg.namedPlaceholderTypes,\n\t\t\t'[a-zA-Z0-9._$]+'\n\t\t);\n\t\tthis.STRING_NAMED_PLACEHOLDER_REGEX = regexFactory.createPlaceholderRegex(\n\t\t\tcfg.namedPlaceholderTypes,\n\t\t\tregexFactory.createStringPattern(cfg.stringTypes)\n\t\t);\n\t}\n\n\t/**\n\t * Takes a SQL string and breaks it into tokens.\n\t * Each token is an object with type and value.\n\t *\n\t * @param {string} input - The SQL string\n\t * @returns {Token[]} output token stream\n\t */\n\ttokenize(input: string): Token[] {\n\t\tconst tokens: Token[] = [];\n\t\tlet token: Token | undefined;\n\n\t\t// Keep processing the string until it is empty\n\t\twhile (input.length) {\n\t\t\t// grab any preceding whitespace\n\t\t\tconst whitespaceBefore = this.getWhitespace(input);\n\t\t\tinput = input.substring(whitespaceBefore.length);\n\n\t\t\tif (input.length) {\n\t\t\t\t// Get the next token and the token type\n\t\t\t\ttoken = this.getNextToken(input, token);\n\t\t\t\t// Advance the string\n\t\t\t\tinput = input.substring(token.value.length);\n\n\t\t\t\ttokens.push({ ...token, whitespaceBefore });\n\t\t\t}\n\t\t}\n\t\treturn tokens;\n\t}\n\n\t/** Matches preceding whitespace if present */\n\tgetWhitespace(input: string): string {\n\t\tconst matches = input.match(this.WHITESPACE_REGEX);\n\t\treturn matches ? matches[1] : '';\n\t}\n\n\t/** Curried function of `getTokenOnFirstMatch` that allows token type to be passed first */\n\tmatchToken =\n\t\t(tokenType: TokenType) =>\n\t\t(input: string): Token | undefined =>\n\t\t\tthis.getTokenOnFirstMatch({\n\t\t\t\tinput,\n\t\t\t\ttype: tokenType,\n\t\t\t\tregex: this.REGEX_MAP[tokenType],\n\t\t\t});\n\n\t/** Attempts to match next token from input string, tests RegExp patterns in decreasing priority */\n\tgetNextToken(input: string, previousToken?: Token) {\n\t\treturn (this.matchToken(TokenType.LINE_COMMENT)(input) ||\n\t\t\tthis.matchToken(TokenType.BLOCK_COMMENT)(input) ||\n\t\t\tthis.matchToken(TokenType.STRING)(input) ||\n\t\t\tthis.matchToken(TokenType.BLOCK_START)(input) ||\n\t\t\tthis.matchToken(TokenType.BLOCK_END)(input) ||\n\t\t\tthis.getPlaceholderToken(input) ||\n\t\t\tthis.matchToken(TokenType.NUMBER)(input) ||\n\t\t\tthis.getReservedWordToken(input, previousToken) ||\n\t\t\tthis.matchToken(TokenType.WORD)(input) ||\n\t\t\tthis.matchToken(TokenType.OPERATOR)(input)) as Token;\n\t}\n\n\t/**\n\t * Attempts to match a placeholder token pattern\n\t * @return {Token | undefined} - The placeholder token if found, otherwise undefined\n\t */\n\tgetPlaceholderToken(input: string): Token | undefined {\n\t\tconst placeholderTokenRegexMap: { regex: RegExp; parseKey: (s: string) => string }[] = [\n\t\t\t// pattern for placeholder with identifier name\n\t\t\t{\n\t\t\t\tregex: this.IDENT_NAMED_PLACEHOLDER_REGEX ?? NULL_REGEX,\n\t\t\t\tparseKey: v => v.slice(1),\n\t\t\t},\n\t\t\t// pattern for placeholder with string name\n\t\t\t{\n\t\t\t\tregex: this.STRING_NAMED_PLACEHOLDER_REGEX ?? NULL_REGEX,\n\t\t\t\tparseKey: v =>\n\t\t\t\t\tthis.getEscapedPlaceholderKey({ key: v.slice(2, -1), quoteChar: v.slice(-1) }),\n\t\t\t},\n\t\t\t// pattern for placeholder with numeric index\n\t\t\t{\n\t\t\t\tregex: this.INDEXED_PLACEHOLDER_REGEX ?? NULL_REGEX,\n\t\t\t\tparseKey: v => v.slice(1),\n\t\t\t},\n\t\t];\n\n\t\treturn placeholderTokenRegexMap.reduce((acc, { regex, parseKey }) => {\n\t\t\tconst token = this.getTokenOnFirstMatch({ input, regex, type: TokenType.PLACEHOLDER });\n\t\t\treturn token ? { ...token, key: parseKey(token.value) } : acc;\n\t\t}, undefined as Token | undefined);\n\t}\n\n\tgetEscapedPlaceholderKey({ key, quoteChar }: { key: string; quoteChar: string }): string {\n\t\treturn key.replace(new RegExp(escapeRegExp('\\\\' + quoteChar), 'gu'), quoteChar);\n\t}\n\n\t/**\n\t * Attempts to match a Reserved word token pattern, avoiding edge cases of Reserved words within string tokens\n\t * @return {Token | undefined} - The Reserved word token if found, otherwise undefined\n\t */\n\tgetReservedWordToken(input: string, previousToken?: Token): Token | undefined {\n\t\t// A reserved word cannot be preceded by a '.', '[', '`', or '\"'\n\t\t// this makes it so for \"mytable.from\", [from], `from`, \"from\" - from is not considered a Reserved word\n\t\tif (previousToken && ['.', '[', '`', '\"'].includes(previousToken.value)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// prioritised list of Reserved token types\n\t\tconst reservedTokenList = [\n\t\t\tTokenType.RESERVED_COMMAND,\n\t\t\tTokenType.RESERVED_BINARY_COMMAND,\n\t\t\tTokenType.RESERVED_DEPENDENT_CLAUSE,\n\t\t\tTokenType.RESERVED_LOGICAL_OPERATOR,\n\t\t\tTokenType.RESERVED_KEYWORD,\n\t\t];\n\n\t\treturn reservedTokenList.reduce(\n\t\t\t(matchedToken, tokenType) => matchedToken || this.matchToken(tokenType)(input),\n\t\t\tundefined as Token | undefined\n\t\t);\n\t}\n\n\t/**\n\t * Attempts to match RegExp from head of input, returning undefined if not found\n\t * @param {string} _.input - The string to match\n\t * @param {TokenType} _.type - The type of token to match against\n\t * @param {RegExp} _.regex - The regex to match\n\t * @return {Token | undefined} - The matched token if found, otherwise undefined\n\t */\n\tgetTokenOnFirstMatch({\n\t\tinput,\n\t\ttype,\n\t\tregex,\n\t}: {\n\t\tinput: string;\n\t\ttype: TokenType;\n\t\tregex: RegExp;\n\t}): Token | undefined {\n\t\tconst matches = input.match(regex);\n\t\treturn matches ? ({ type, value: matches[1] } as Token) : undefined;\n\t}\n}\n"],"file":"Tokenizer.js"}
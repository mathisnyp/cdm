{"version":3,"sources":["../../src/core/regexFactory.ts"],"names":["createOperatorRegex","monadOperators","polyadOperators","RegExp","map","escapeRegExp","join","split","createLineCommentRegex","lineCommentTypes","c","createReservedWordRegex","reservedKeywords","specialWordChars","length","reservedKeywordsPattern","replace","createWordRegex","specialChars","prefixLookBehind","prefix","suffixLookAhead","suffix","unicodeWordChar","any","arrayAccessor","mapAccessor","patterns","createStringPattern","stringTypes","t","createStringRegex","escapeParen","paren","createParenRegex","parens","createPlaceholderRegex","types","pattern","undefined","typesRegex"],"mappings":"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","sourcesContent":["import { escapeRegExp, isEmpty, sortByLengthDesc } from '../utils';\n\n/**\n * Builds a RegExp containing all operators for a SQL dialect\n * @param {string} monadOperators - concatenated string of all 1-length operators\n * @param {string[]} polyadOperators - list of strings of all >1-length operators\n */\nexport const createOperatorRegex = (monadOperators: string, polyadOperators: string[]): RegExp =>\n\tnew RegExp(\n\t\t`^(${sortByLengthDesc(polyadOperators).map(escapeRegExp).join('|')}|` +\n\t\t\t`[${monadOperators.split('').map(escapeRegExp).join('')}])`,\n\t\t'u'\n\t);\n\n/**\n * Builds a RegExp for valid line comments in a SQL dialect\n * @param {string[]} lineCommentTypes - list of character strings that denote line comments\n */\nexport const createLineCommentRegex = (lineCommentTypes: string[]): RegExp =>\n\tnew RegExp(\n\t\t`^((?:${lineCommentTypes.map(c => escapeRegExp(c)).join('|')}).*?)(?:\\r\\n|\\r|\\n|$)`,\n\t\t'u'\n\t);\n\n/**\n * Builds a RegExp for all Reserved Keywords in a SQL dialect\n * @param {string[]} reservedKeywords - list of strings of all Reserved Keywords\n * @param {string} specialWordChars - concatenated string of all special chars that can appear in valid identifiers (and not in Reserved Keywords)\n */\nexport const createReservedWordRegex = (\n\treservedKeywords: string[],\n\tspecialWordChars: string = ''\n): RegExp => {\n\tif (reservedKeywords.length === 0) {\n\t\treturn new RegExp(`^\\b$`, 'u');\n\t}\n\tconst reservedKeywordsPattern = sortByLengthDesc(reservedKeywords)\n\t\t.join('|')\n\t\t.replace(/ /gu, '\\\\s+');\n\treturn new RegExp(\n\t\t`^(${reservedKeywordsPattern})(?![${escapeRegExp(specialWordChars)}]+)\\\\b`,\n\t\t'iu'\n\t);\n};\n\n/**\n * Builds a RegExp for valid identifiers in a SQL dialect\n * @param {Object} specialChars\n * @param {string} specialChars.any - concatenated string of chars that can appear anywhere in a valid identifier\n * @param {string} specialChars.prefix - concatenated string of chars that only appear at the beginning of a valid identifier\n * @param {string} specialChars.suffix - concatenated string of chars that only appear at the end of a valid identifier\n */\nexport const createWordRegex = (\n\tspecialChars: { any?: string; prefix?: string; suffix?: string } = {}\n): RegExp => {\n\tconst prefixLookBehind = `[${escapeRegExp(specialChars.prefix ?? '')}]*`;\n\tconst suffixLookAhead = `[${escapeRegExp(specialChars.suffix ?? '')}]*`;\n\tconst unicodeWordChar =\n\t\t'\\\\p{Alphabetic}\\\\p{Mark}\\\\p{Decimal_Number}\\\\p{Connector_Punctuation}\\\\p{Join_Control}';\n\tconst specialWordChars = `${escapeRegExp(specialChars.any ?? '')}`;\n\n\tconst arrayAccessor = '\\\\[\\\\d\\\\]';\n\tconst mapAccessor = `\\\\[['\"][${unicodeWordChar}]+['\"]\\\\]`;\n\n\treturn new RegExp(\n\t\t`^((${prefixLookBehind}([${unicodeWordChar}${specialWordChars}]+)${suffixLookAhead})(${arrayAccessor}|${mapAccessor})?)`,\n\t\t'u'\n\t);\n};\n\n// This enables the following string patterns:\n// 1. backtick quoted string using `` to escape\n// 2. square bracket quoted string (SQL Server) using ]] to escape\n// 3. double quoted string using \"\" or \\\" to escape\n// 4. single quoted string using '' or \\' to escape\n// 5. national character quoted string using N'' or N\\' to escape\n// 6. Unicode single-quoted string using \\' to escape\n// 7. Unicode double-quoted string using \\\" to escape\n// 8. PostgreSQL dollar-quoted strings\nconst patterns = {\n\t'``': '((`[^`]*($|`))+)',\n\t'{}': '((\\\\{[^\\\\}]*($|\\\\}))+)',\n\t'[]': '((\\\\[[^\\\\]]*($|\\\\]))(\\\\][^\\\\]]*($|\\\\]))*)',\n\t'\"\"': '((\"[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*(\"|$))+)',\n\t\"''\": \"(('[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*('|$))+)\",\n\t\"N''\": \"((N'[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*('|$))+)\",\n\t\"x''\": \"((x'[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*('|$))+)\",\n\t\"U&''\": \"((U&'[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*('|$))+)\",\n\t'U&\"\"': '((U&\"[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*(\"|$))+)',\n\t'$$': '((?<tag>\\\\$\\\\w*\\\\$)[\\\\s\\\\S]*?(?:\\\\k<tag>|$))',\n};\nexport type StringPatternType = keyof typeof patterns;\n\n/**\n * Builds a string pattern for matching string patterns for all given string types\n * @param {StringPatternType[]} stringTypes - list of strings that denote string patterns\n */\nexport const createStringPattern = (stringTypes: StringPatternType[]): string =>\n\tstringTypes.map(t => patterns[t]).join('|');\n\n/**\n * Builds a RegExp for matching string patterns using `createStringPattern`\n * @param {StringPatternType[]} stringTypes - list of strings that denote string patterns\n */\nexport const createStringRegex = (stringTypes: StringPatternType[]): RegExp =>\n\tnew RegExp('^(' + createStringPattern(stringTypes) + ')', 'u');\n\n/** Escapes paren characters for RegExp patterns */\nconst escapeParen = (paren: string): string => {\n\tif (paren.length === 1) {\n\t\t// A single punctuation character\n\t\treturn escapeRegExp(paren);\n\t} else {\n\t\t// longer word\n\t\treturn '\\\\b' + paren + '\\\\b';\n\t}\n};\n\n/**\n * Builds a RegExp for matching parenthesis patterns, escaping them with `escapeParen`\n * @param {string[]} parens - list of strings that denote parenthesis patterns\n */\nexport const createParenRegex = (parens: string[]): RegExp =>\n\tnew RegExp('^(' + parens.map(escapeParen).join('|') + ')', 'iu');\n\n/**\n * Builds a RegExp for placeholder patterns\n * @param {string[]} types - list of strings that denote placeholder types\n * @param {string} pattern - string that denotes placeholder pattern\n */\nexport const createPlaceholderRegex = (types: string[], pattern: string): RegExp | undefined => {\n\tif (isEmpty(types)) {\n\t\treturn undefined;\n\t}\n\tconst typesRegex = types.map(escapeRegExp).join('|');\n\n\treturn new RegExp(`^((?:${typesRegex})(?:${pattern}))`, 'u');\n};\n"],"file":"regexFactory.js"}
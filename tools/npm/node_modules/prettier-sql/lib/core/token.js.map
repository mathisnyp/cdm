{"version":3,"sources":["../../src/core/token.ts"],"names":["TokenType","ZWS","ZWS_REGEX","spaces","testToken","compareToken","token","type","RegExp","value","test","isToken","AS","RESERVED_KEYWORD","AND","RESERVED_LOGICAL_OPERATOR","BETWEEN","CASE","BLOCK_START","CAST","BY","END","BLOCK_END","FROM","RESERVED_COMMAND","LATERAL","RESERVED_DEPENDENT_CLAUSE","LIMIT","SELECT","SET","TABLE","WINDOW","WITH","isCommand","RESERVED_BINARY_COMMAND","isReserved"],"mappings":"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","sourcesContent":["/** Token type enum for all possible Token categories */\nexport enum TokenType {\n\tWORD = 'WORD',\n\tSTRING = 'STRING',\n\tRESERVED_KEYWORD = 'RESERVED_KEYWORD',\n\tRESERVED_LOGICAL_OPERATOR = 'RESERVED_LOGICAL_OPERATOR',\n\tRESERVED_DEPENDENT_CLAUSE = 'RESERVED_DEPENDENT_CLAUSE',\n\tRESERVED_BINARY_COMMAND = 'RESERVED_BINARY_COMMAND',\n\tRESERVED_COMMAND = 'RESERVED_COMMAND',\n\tOPERATOR = 'OPERATOR',\n\tBLOCK_START = 'BLOCK_START',\n\tBLOCK_END = 'BLOCK_END',\n\tLINE_COMMENT = 'LINE_COMMENT',\n\tBLOCK_COMMENT = 'BLOCK_COMMENT',\n\tNUMBER = 'NUMBER',\n\tPLACEHOLDER = 'PLACEHOLDER',\n}\n\n/** Struct to store the most basic cohesive unit of language grammar */\nexport interface Token {\n\tvalue: string;\n\ttype: TokenType;\n\tkey?: string;\n\twhitespaceBefore?: string;\n}\n\n/** Special Unicode character to serve as a placeholder for TenSpace formats as \\w whitespace is unavailable */\nexport const ZWS = 'â€‹'; // uses zero-width space (&#8203; / U+200B)\nconst ZWS_REGEX = '\\u200b';\nconst spaces = `[${ZWS_REGEX}\\\\s]`;\n\n/** Checks if two tokens are equivalent */\nexport const testToken =\n\t(compareToken: Token) =>\n\t(token: Token): boolean =>\n\t\ttoken?.type === compareToken.type &&\n\t\tnew RegExp(`^${spaces}*${compareToken.value}${spaces}*$`, 'iu').test(token?.value);\n\n/** Util object that allows for easy checking of Reserved Keywords */\nexport const isToken = {\n\tAS: testToken({ value: 'AS', type: TokenType.RESERVED_KEYWORD }),\n\tAND: testToken({ value: 'AND', type: TokenType.RESERVED_LOGICAL_OPERATOR }),\n\tBETWEEN: testToken({ value: 'BETWEEN', type: TokenType.RESERVED_KEYWORD }),\n\tCASE: testToken({ value: 'CASE', type: TokenType.BLOCK_START }),\n\tCAST: testToken({ value: 'CAST', type: TokenType.RESERVED_KEYWORD }),\n\tBY: testToken({ value: 'BY', type: TokenType.RESERVED_KEYWORD }),\n\tEND: testToken({ value: 'END', type: TokenType.BLOCK_END }),\n\tFROM: testToken({ value: 'FROM', type: TokenType.RESERVED_COMMAND }),\n\tLATERAL: testToken({ value: 'LATERAL', type: TokenType.RESERVED_DEPENDENT_CLAUSE }),\n\tLIMIT: testToken({ value: 'LIMIT', type: TokenType.RESERVED_COMMAND }),\n\tSELECT: testToken({ value: 'SELECT', type: TokenType.RESERVED_COMMAND }),\n\tSET: testToken({ value: 'SET', type: TokenType.RESERVED_COMMAND }),\n\tTABLE: testToken({ value: 'TABLE', type: TokenType.RESERVED_KEYWORD }),\n\tWINDOW: testToken({ value: 'WINDOW', type: TokenType.RESERVED_COMMAND }),\n\tWITH: testToken({ value: 'WITH', type: TokenType.RESERVED_COMMAND }),\n};\n\n/** Checks if token is a Reserved Command or Reserved Binary Command */\nexport const isCommand = (token: Token): boolean =>\n\ttoken &&\n\t(token.type === TokenType.RESERVED_COMMAND || token.type === TokenType.RESERVED_BINARY_COMMAND);\n\n/** Checks if token is any Reserved Keyword or Command */\nexport const isReserved = (token: Token): boolean =>\n\ttoken &&\n\t(token.type === TokenType.RESERVED_KEYWORD ||\n\t\ttoken.type === TokenType.RESERVED_LOGICAL_OPERATOR ||\n\t\ttoken.type === TokenType.RESERVED_DEPENDENT_CLAUSE ||\n\t\ttoken.type === TokenType.RESERVED_COMMAND ||\n\t\ttoken.type === TokenType.RESERVED_BINARY_COMMAND);\n"],"file":"token.js"}
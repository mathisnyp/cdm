import Indentation from './Indentation';
import InlineBlock from './InlineBlock';
import Params from './Params';
import { Token } from './token';
import Tokenizer from './Tokenizer';
import type { FormatOptions } from '../sqlFormatter';
/** Main formatter class that produces a final output string from list of tokens */
export default class Formatter {
    cfg: FormatOptions & {
        tenSpace?: boolean;
    };
    newline: FormatOptions['newline'];
    currentNewline: boolean;
    lineWidth: number;
    indentation: Indentation;
    inlineBlock: InlineBlock;
    params: Params;
    previousReservedToken: Token;
    withinSelect: boolean;
    tokens: Token[];
    index: number;
    /**
     *	@param {FormatOptions} cfg - config object
     *	@param {string} cfg.language - the current SQL dialect
     *	@param {string} cfg.indent - the indentation string, either tabs or a number of spaces
     *	@param {Boolean} cfg.uppercase - whether to use uppercase keywords
     *	@param {NewlineMode} cfg.newline - setting to control when to break onto newlines
     *	@param {Integer} cfg.lineWidth - the maximum line width before breaking
     *	@param {Integer} cfg.linesBetweenQueries - the number of blank lines between each query
     *	@param {ParamItems | string[]} cfg.params - placeholder tokens to substitute
     */
    constructor(cfg: FormatOptions);
    /**
     * SQL Tokenizer for this formatter, provided by subclasses.
     */
    tokenizer(): Tokenizer;
    /**
     * Reprocess and modify a token based on parsed context.
     *
     * @param {Token} token - The token to modify
     * @return {Token} new token or the original
     */
    tokenOverride(token: Token): Token;
    /**
     * Formats whitespace in a SQL string to make it easier to read.
     *
     * @param {string} query - The SQL query string
     */
    format(query: string): string;
    /**
     * Does post-processing on the formatted query.
     * @param {string} query - the query string produced from `this.format`
     */
    postFormat(query: string): string;
    /**
     * Handles comma placement - either before, after or tabulated
     * @param {string} query - input query string
     */
    formatCommaPositions(query: string): string;
    /**
     * Handles select alias placement - tabulates if enabled
     * @param {string} query - input query string
     */
    formatAliasPositions(query: string): string;
    /**
     * Performs main construction of query from token list, delegates to other methods for formatting based on token criteria
     * @return {string} formatted query
     */
    getFormattedQueryFromTokens(): string;
    /**
     * Formats word tokens + any potential AS tokens for aliases
     * @param {Token} token - current token
     * @param {string} query - formatted query so far
     */
    formatWord(token: Token, query: string): string;
    /**
     * Checks if a newline should currently be inserted
     * @param {number} index - index of current token
     * @return {boolean} Whether or not a newline should be inserted
     */
    checkNewline(index: number): boolean;
    /** Formats a line comment onto query */
    formatLineComment(token: Token, query: string): string;
    /** Formats a block comment onto query */
    formatBlockComment(token: Token, query: string): string;
    /** Aligns comment to current indentation level */
    indentComment(comment: string): string;
    /**
     * Formats a Reserved Command onto query, increasing indentation level where necessary
     * @param {Token} token - current token
     * @param {string} query - formatted query so far
     */
    formatCommand(token: Token, query: string): string;
    /**
     * Formats a Reserved Binary Command onto query, joining neighbouring tokens
     * @param {Token} token - current token
     * @param {string} query - formatted query so far
     */
    formatBinaryCommand(token: Token, query: string): string;
    /**
     * Formats a Reserved Keyword onto query, skipping AS if disabled
     * @param {Token} token - current token
     * @param {string} query - formatted query so far
     */
    formatKeyword(token: Token, query: string): string;
    /**
     * Formats a Reserved Dependent Clause token onto query, supporting the keyword that precedes it
     * @param {Token} token - current token
     * @param {string} query - formatted query so far
     */
    formatDependentClause(token: Token, query: string): string;
    /**
     * Formats an Operator onto query, following rules for specific characters
     * @param {Token} token - current token
     * @param {string} query - formatted query so far
     */
    formatOperator(token: Token, query: string): string;
    /**
     * Formats a Logical Operator onto query, joining boolean conditions
     * @param {Token} token - current token
     * @param {string} query - formatted query so far
     */
    formatLogicalOperator(token: Token, query: string): string;
    /** Replace any sequence of whitespace characters with single space */
    equalizeWhitespace(string: string): string;
    /**
     * Formats a Block Start token (left paren/bracket/brace, CASE) onto query, beginning an Inline Block or increasing indentation where necessary
     * @param {Token} token - current token
     * @param {string} query - formatted query so far
     */
    formatBlockStart(token: Token, query: string): string;
    /**
     * Formats a Block End token (right paren/bracket/brace, END) onto query, closing an Inline Block or decreasing indentation where necessary
     * @param {Token} token - current token
     * @param {string} query - formatted query so far
     */
    formatBlockEnd(token: Token, query: string): string;
    /**
     * Formats a Placeholder item onto query, to be replaced with the value of the placeholder
     * @param {Token} token - current token
     * @param {string} query - formatted query so far
     */
    formatPlaceholder(token: Token, query: string): string;
    /**
     * Formats a comma Operator onto query, ending line unless in an Inline Block
     * @param {Token} token - current token
     * @param {string} query - formatted query so far
     */
    formatComma(token: Token, query: string): string;
    /** Simple append of token onto query */
    formatWithoutSpaces(token: Token, query: string): string;
    /**
     * Add token onto query with spaces - either before, after, or both
     * @param {Token} token - current token
     * @param {string} query - formatted query so far
     * @param {'before' | 'after' | 'both'} addSpace - where to add spaces around token
     * @return {string} token string with specified spaces
     */
    formatWithSpaces(token: Token, query: string, addSpace?: 'before' | 'after' | 'both'): string;
    /**
     * Format Delimiter token onto query, adding newlines accoring to `this.cfg.linesBetweenQueries`
     * @param {Token} token - current token
     * @param {string} query - formatted query so far
     */
    formatQuerySeparator(token: Token, query: string): string;
    /** Converts token to string, uppercasing if enabled */
    show(token: Token): string;
    /** Inserts a newline onto the query */
    addNewline(query: string): string;
    /** Produces a 10-char wide version of reserved token for TenSpace modes */
    tenSpacedToken(token: Token): Token;
    /** Fetches nth previous token from the token stream */
    tokenLookBehind(n?: number): Token;
    /** Fetches nth next token from the token stream */
    tokenLookAhead(n?: number): Token;
}

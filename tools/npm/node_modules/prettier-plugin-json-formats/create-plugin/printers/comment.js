"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printComments = exports.printTrailingComment = exports.printLeadingComment = exports.printComment = void 0;
const prettier_1 = require("prettier");
const utils_1 = require("./utils");
const { breakParent, cursor, hardline, join, lineSuffix } = prettier_1.doc.builders;
function isIndentableBlockComment(comment) {
    // If the comment has multiple lines and every line starts with a star
    // we can fix the indentation of each line. The stars in the `/*` and
    // `*/` delimiters are not included in the comment value, so add them
    // back first.
    const lines = `*${comment.comment}*`.split('\n');
    return lines.length > 1 && lines.every(line => line.trim().startsWith('*'));
}
function printIndentableBlockComment(comment) {
    const lines = comment.comment.split('\n');
    return [
        '/*',
        join(hardline, lines.map((line, index) => index === 0
            ? line.trimRight()
            : ' ' + (index < lines.length - 1 ? line.trim() : line.trimLeft()))),
        '*/',
    ];
}
function printComment(commentPath, options, ensureSafeForContentAfter = false) {
    const comment = commentPath.getValue();
    switch (comment.type) {
        case 'multi-line comment': {
            if (isIndentableBlockComment(comment)) {
                return printIndentableBlockComment(comment);
            }
            return ('/*' + comment.comment + '*/' + (ensureSafeForContentAfter ? ' ' : ''));
        }
        case 'single line comment':
            return [
                // Print shebangs with the proper comment characters
                options.originalText.slice(options.locStart(comment)).startsWith('#!')
                    ? '#!'
                    : '// ',
                comment.comment.trim(),
                ensureSafeForContentAfter ? hardline : '',
            ];
        default:
            throw new Error('Not a comment: ' + JSON.stringify(comment));
    }
}
exports.printComment = printComment;
function printLeadingComment(commentPath, options) {
    var _a, _b;
    const comment = commentPath.getValue();
    const contents = printComment(commentPath, options);
    if (!contents) {
        return '';
    }
    const isBlock = (_b = (_a = options.printer).isBlockComment) === null || _b === void 0 ? void 0 : _b.call(_a, comment);
    // Leading block comments should see if they need to stay on the
    // same line or not.
    if (!isBlock) {
        return contents;
    }
    return [
        contents,
        (0, utils_1.hasNewline)(options.originalText, options.locEnd(comment)) ? hardline : ' ',
    ];
}
exports.printLeadingComment = printLeadingComment;
function printTrailingComment(commentPath, options, ensureSafeForContentAfter = false) {
    var _a, _b;
    const comment = commentPath.getValue();
    const contents = printComment(commentPath, options, ensureSafeForContentAfter);
    if (!contents) {
        return '';
    }
    const isBlock = (_b = (_a = options.printer).isBlockComment) === null || _b === void 0 ? void 0 : _b.call(_a, comment);
    if ((0, utils_1.hasNewline)(options.originalText, options.locStart(comment), {
        backwards: true,
    })) {
        // This allows comments at the end of nested structures:
        // {
        //   x: 1,
        //   y: 2
        //   // A comment
        // }
        // Those kinds of comments are almost always leading comments, but
        // here it doesn't go "outside" the block and turns it into a
        // trailing comment for `2`. We can simulate the above by checking
        // if this a comment on its own line; normal trailing comments are
        // always at the end of another expression.
        const isLineBeforeEmpty = (0, utils_1.isPreviousLineEmpty)(options.originalText, comment, options.locStart);
        return lineSuffix([hardline, isLineBeforeEmpty ? hardline : '', contents]);
    }
    else if (isBlock) {
        // Trailing block comments never need a newline
        return [' ', contents];
    }
    return [lineSuffix([' ', contents]), !isBlock ? breakParent : ''];
}
exports.printTrailingComment = printTrailingComment;
function prependCursorPlaceholder(path, options, printed) {
    if (path.getNode() ===
        options.cursorNode &&
        path.getValue()) {
        return [cursor, printed, cursor];
    }
    return printed;
}
function isEmpty(arr) {
    return !!(arr === null || arr === void 0 ? void 0 : arr.length);
}
function printComments(path, print, options) {
    const value = path.getValue();
    const printed = print(path);
    if (!value ||
        (isEmpty(value.leadingComments) && isEmpty(value.trailingComments))) {
        return prependCursorPlaceholder(path, options, printed);
    }
    const leadingParts = path.map((commentPath) => {
        const contents = printLeadingComment(commentPath, options);
        const text = options.originalText;
        const index = (0, utils_1.skipNewline)(text, options.locEnd(commentPath.getNode()));
        if (index !== false && (0, utils_1.hasNewline)(text, index)) {
            return [contents, hardline];
        }
        else {
            return contents;
        }
    }, 'leadingComments');
    const trailingParts = [
        printed,
        ...path.map((commentPath) => printTrailingComment(commentPath, options), 'trailingComments'),
    ];
    return prependCursorPlaceholder(path, options, leadingParts.concat(trailingParts));
}
exports.printComments = printComments;
